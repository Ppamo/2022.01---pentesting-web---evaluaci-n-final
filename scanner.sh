#!/bin/bash

LANG=en_US.UTF-8
LANGUAGE=en_US:en
VERBOSE=0
OUTPUT_FILE=

if [ "$COLOR" != "false" ]
then
	RED='\e[31m'
	GREEN='\e[32m'
	BLUE='\e[36m'
	YELLOW='\e[33m'
	BOLD='\e[1m'
	DIM='\e[2m'
	BLINK='\e[5m'
	RESET='\e[39m\e[0m'
fi

usage(){
	printf "\n${GREEN}Usage:
	${BLUE}$0${RESET} ${YELLOW}[COMANDOS...]${RESET}

${GREEN}Comandos disponibles:${RESET}
	help: Muestra esta ayuda
	hosts (-H): Enumera los hosts disponibles dada una máscara de red
	ports (-P): Enumera puertos disponibles en la máquina destino
	sniff (-S): Captura paquetes desde la interfaz de red indicada
	verbose (-V): Activa/Desactiva el modo verboso

${GREEN}Ejemplo:${RESET}

	> $0 hosts 192.168.1.0/24
	> $0 -H 192.168.1.0/24
	Los comandos anteriores inician un escaneo en busqueda de hosts en la red 192.168.1.0 con submascara de red 24

	> $0 ports 192.168.1.1
	> $0 -P 192.168.1.1
	Los comandos anteriores inician un escaneo de puertos al host 192.168.1.1

	> $0 verbose sniff eth0
	> $0 -V -S eth0
	Los comandos anteriores activan el modo verboso e inician una captura de paquetes en la interfaz eth0

"
	
}

# # #

error(){
	printf "! ${RED}ERROR:${RESET} %s\n" "$1"
}

show_port_info(){
	[ $VERBOSE -eq 1 ] && printf "${GREEN}%s ${RESET}> Puerto abierto\n" "$2" || echo -n " $2 "
	local OUTPUT=$(timeout 1 bash -c "cat </dev/tcp/$1/$2" | tr -d '\0' | sed -e :a -e ';$!N;s/\n//;ta')
	OUTPUT="${OUTPUT//[^a-zA-Z0-9_ \/\.;:\|]/}"
	# Check if it speaks HTTP
	local HEAD=$(timeout 2 curl -s --head http://$1:$2 2>&1)
	if [ $? -eq 0 ]; then
		HEAD=$(echo "$HEAD" | sed -e :a -e ';$!N;s/\n/; /;ta' | tr '\n' ';')
		HEAD="${HEAD//[^a-zA-Z0-9_ \/\.;:\|]/}"
		printf "%i > %s >> %s\n" "$2" "$OUTPUT" "$HEAD" >> $OUTPUT_FILE
	else
		printf "%i > %s\n" "$2" "$OUTPUT" >> $OUTPUT_FILE
	fi
}

show_host_info(){
	[ $VERBOSE -eq 1 ] && printf "${GREEN}%s ${RESET}> Host encontrado\n" "$1" || echo -n " $1 "
}

scan_ports(){
	local TARGET=$1
	rm -f $OUTPUT_FILE
	printf "${YELLOW}*${GREEN} Buscando puertos abiertos en ${YELLOW}%s\n${RESET}" "$TARGET"
	arping -c 1 -w 1 $TARGET > /dev/null 2>&1
	if [ $? -ne 0 ]; then
		error "Target not found"
		exit 1
	fi
	for I in $(seq 1 65535); do
		if [ $(( $I % 5000 )) -eq 0 ]; then
			[ $VERBOSE -eq 1 ] && printf "${YELLOW}>>${RESET} escaneados %5i puertos\n" "$I" || echo -n "."
		fi
		timeout 1 bash -c "< /dev/tcp/$1/$I" 2>/dev/null && show_port_info "$TARGET" "$I"  &
	done; wait
	printf "\n\n${YELLOW}* ${GREEN}Resultados:\n${RESET}"
	cat $OUTPUT_FILE | sort -n
}

get_int_from_ip(){
	local o1 o2 o3 o4
	{ IFS=. read o1 o2 o3 o4; } <<< $1
	echo $(((((((o1 << 8) | o2) << 8) | o3) << 8) | o4))
}

get_ip_from_int(){
	local IP N INT=$1
	for N in 1 2 3 4; do
		IP=$((INT & 0xff))${IP:+.}$IP
		INT=$((INT >> 8))
	done
	echo $IP
}

get_class_from_mask(){
	echo 1
}

get_ip_from_netmask(){
	local VALUE=$((0xffffffff << (32 - $1)))
	printf "%i.%i.%i.%i" "$((($VALUE & 0xFF000000) >> 24))" "$((($VALUE & 0xFF0000) >> 16))" \
		"$((($VALUE & 0xFF00) >> 8))" "$(($VALUE & 0xFF))"
}

get_wildcard_from_netmask(){
	local VALUE=$((0xffffffff << (32 - $1)))
	VALUE=$(( ~$VALUE ))
	printf "%i.%i.%i.%i" "$((($VALUE & 0xFF000000) >> 24))" "$((($VALUE & 0xFF0000) >> 16))" \
		"$((($VALUE & 0xFF00) >> 8))" "$(($VALUE & 0xFF))"
}

echo_byte() {
	local N BITS
	for (( N=$1; N>0; N>>=1)); do
		BITS=$((N&1))$BITS;
	done
	printf "%08i" "${BITS-0}"
}

get_bit_from_ip(){
	local S
	for S in $(echo "$1" | tr . " " ); do
		echo -n "$(echo_byte $S) "
	done
}

get_network_from_address_mask(){
	local NETWORK
	IFS='.' read -r -a ADDRESS <<< "$1"
	IFS='.' read -r -a MASK <<< "$2"
	for I in $(seq 0 3); do
		NETWORK="$NETWORK.$(( ${ADDRESS[$I]} & ${MASK[$I]} ))"
	done
	printf "%s" "${NETWORK#.*}"
}

get_broadcast_from_network_and_wildcard(){
	local BROADCAST
	IFS='.' read -r -a NETWORK <<< "$1"
	IFS='.' read -r -a WILDCARD <<< "$2"
	for I in $(seq 0 3); do
		BROADCAST="$BROADCAST.$(( ${NETWORK[$I]} | ${WILDCARD[$I]} ))"
	done
	printf "%s" "${BROADCAST#.*}"
}

format_net_info(){
	printf "  %s:\t%s\t\t%s\n" "$1" "$2" "$(get_bit_from_ip $2)"
}

scan_hosts(){
	local TARGET=$1
	local ADDRESS=${TARGET%/*}
	local MASK=${TARGET#*/}
	local NETMASK=$(get_ip_from_netmask $MASK)
	local WILDCARD=$(get_wildcard_from_netmask $MASK)
	local NETWORK=$(get_network_from_address_mask "$ADDRESS" "$NETMASK")
	local BROADCAST=$( get_broadcast_from_network_and_wildcard "$NETWORK" "$WILDCARD" )
	local HOSTMIN HOSTMAX HOSTMIN_INT HOSTMAX_INT IP HOST_INT
	HOSTMIN_INT=$(get_int_from_ip $NETWORK)
	HOSTMIN_INT=$(( ++HOSTMIN_INT ))
	HOSTMIN=$( get_ip_from_int $HOSTMIN_INT )
	HOSTMAX_INT=$(get_int_from_ip $BROADCAST)
	HOSTMAX_INT=$(( --HOSTMAX_INT ))
	HOSTMAX=$( get_ip_from_int $HOSTMAX_INT )

	printf ${YELLOW}"* ${GREEN}Calculando informacion de la red:\n"${RESET}
	format_net_info "Address" "$ADDRESS"
	format_net_info "Netmask" "$NETMASK"
	format_net_info "Wildcard" "$WILDCARD"
	echo
	format_net_info "Network" "$NETWORK"
	format_net_info "Broadcast" "$BROADCAST"
	format_net_info "HostMin" "$HOSTMIN"
	format_net_info "HostMax" "$HOSTMAX"
	echo

	HOST_INT=$HOSTMIN_INT
	printf "${YELLOW}* ${GREEN}Buscando hosts\n"${RESET}
	while [ $HOST_INT -lt $HOSTMAX_INT ]; do
		IP=$(get_ip_from_int $HOST_INT)
		HOST_INT=$(( HOST_INT + 1 ))
		[ "${IP#*.*.*.*}" == "0" -o "${IP#*.*.*.*}" == "255" ] && continue
		# printf "Scanning %s\n" "$IP" >> $OUTPUT_FILE
		arping -c 1 -w 5 "$IP" > /dev/null && show_host_info "$IP" &
	done; wait
}

# # #

if [ -z "$1" ]
then
	usage
fi

ARGS=("${@}")
I=0
while [ $I -lt ${#ARGS[@]} ]
do
	OUTPUT_FILE=
	TIMESTAMP=$(date "+%Y%m%d.%H%M%S")
	COMMAND=${ARGS[$I]}
	case "$COMMAND" in
		help)
			usages
			;;
		hosts|-H)
			OUTPUT_FILE=$TIMESTAMP-hosts.log
			scan_hosts "${ARGS[@]:$(($I+1))}"
			I=$(( I+1 ))
			;;
		ports|-P)
			OUTPUT_FILE=$TIMESTAMP-ports.log
			scan_ports "${ARGS[@]:$(($I+1))}"
			I=$(( I+2 ))
			;;
		sniff|-S)
			OUTPUT_FILE=$TIMESTAMP-dump.pcap
			sniff "${ARGS[@]:$(($I+1))}"
			I=$(( I+2 ))
			;;
		verbose|-V)
			VERBOSE=$([ $VERBOSE -eq 1 ] && echo 0 || echo 1)
			if [ $VERBOSE -eq 1 ]; then
				printf "${YELLOW}* ${GREEN}Activado modo verboso\n${RESET}"
			else
				printf "${YELLOW}* ${GREEN}Desactivado modo verboso\n${RESET}"
			fi
			;;
		*)
			printf "* ERROR: Command '$command' not found\n"
			usage
			exit 1
	esac
	I=$(( I+1 ))
	echo
done

#################################################################
# *** Grupo N°1 *** 						#
# - Integrante 1: Camilo Hernan Rojas Vera			#
# - Integrante 2: Cristian Francisco Rocco Salgado		#
# - Integrante 3: Pablo Andrés Mansilla Ojeda			#
# - Integrante 4: Diego Nicolas Espindola Olav			#
# - Integrante 5: Misael Hemdan Israel López Flores		#
#################################################################
