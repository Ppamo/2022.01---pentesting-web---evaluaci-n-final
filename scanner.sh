#!/bin/bash

LANG=en_US.UTF-8
LANGUAGE=en_US:en
VERBOSE=0
OUTPUT_FILE=

if [ "$COLOR" != "false" ]
then
	RED='\e[31m'
	GREEN='\e[32m'
	BLUE='\e[36m'
	YELLOW='\e[33m'
	BOLD='\e[1m'
	DIM='\e[2m'
	BLINK='\e[5m'
	RESET='\e[39m\e[0m'
fi

usage(){
	printf "\n${GREEN}Usage:
	${BLUE}$0${RESET} ${YELLOW}[COMANDOS...]${RESET}

${GREEN}Comandos disponibles:${RESET}
	help: Muestra esta ayuda
	hosts (-H): Enumera los hosts disponibles dada una red y mascara
	ports (-P): Enumera puertos disponibles en la máquina destino
	sniff (-S): Captura paquetes desde la interfaz de red indicada
	menu (-m): Muestra un menu de opciones para estos mismos comandos
	verbose (-v): Activa/Desactiva el modo verboso

${GREEN}Ejemplos:${RESET}
	> $0 hosts 192.168.1.0/24
	> $0 -H 192.168.1.0/24
	Los comandos anteriores inician un escaneo en busqueda de hosts en la red 192.168.1.0 con mascara de red 24

	> $0 ports 192.168.1.1
	> $0 -P 192.168.1.1
	Los comandos anteriores inician un escaneo de puertos al host 192.168.1.1

	> $0 verbose sniff eth0
	> $0 -v -S eth0
	Los comandos anteriores activan el modo verboso e inician una captura de paquetes en la interfaz eth0

"
	
}

# # #

error(){
	printf "! ${RED}ERROR:${RESET} %s\n" "$1"
}

# Inicia la captura de paquetes desde la interfaz de red indicada, utilizando tcpdump.
# Una vez terminada la captura imprime las distintas direcciones mac encontradas.
start_sniff(){
	local DEVICE=$1
	printf "${YELLOW}*${GREEN} Iniciando captura de paquetes desde la interfaz ${YELLOW}%s${RESET}\n"
	tcpdump --list-interfaces | awk -F '[. ]' '{ print $2 }' | grep -E "^$DEVICE$" > /dev/null 2>&1
	if [ $? -ne 0 ]; then
		error "Interfaz de red no encontrada"
		exit 1
	fi
	printf "Presione ^C para terminar la captura...\n" "$DEVICE"
	tcpdump -c 10000 -i $DEVICE -w $OUTPUT_FILE
	if [ $VERBOSE -eq 1 ]; then
		printf "${YELLOW}*${GREEN} MACs distintas encontradas\n${RESET}"
		tcpdump -nOqe -r "$OUTPUT_FILE" 2>/dev/null | awk '{ print $2, $4 }' | \
			sed 's/,//g' | awk '1' RS='[[:space:]]+' | sort -u | sed 's/^/  /g'
	fi
	printf "${YELLOW}* ${GREEN}La captura se encuentra en ${YELLOW}%s\n${RESET}" "$OUTPUT_FILE"
}

# Muestra información relacionada a un puerto abierto, encontrado durante el escaneo
show_port_info(){
	[ $VERBOSE -eq 1 ] && printf "${GREEN}%s ${RESET}> Puerto abierto\n" "$2" || echo -n " $2 "
	local OUTPUT=$(timeout 1 bash -c "cat </dev/tcp/$1/$2" | tr -d '\0' | sed -e :a -e ';$!N;s/\n//;ta')
	OUTPUT="${OUTPUT//[^a-zA-Z0-9_ \/\.;:\|]/}"
	# Check if it speaks HTTP
	local HEAD=$(timeout 2 curl -s --head http://$1:$2 2>&1)
	if [ $? -eq 0 ]; then
		HEAD=$(echo "$HEAD" | sed -e :a -e ';$!N;s/\n/; /;ta' | tr '\n' ';')
		HEAD="${HEAD//[^a-zA-Z0-9_ \/\.;:\|]/}"
		printf "%i > %s >> %s\n" "$2" "$OUTPUT" "$HEAD" >> $OUTPUT_FILE
	else
		printf "%i > %s\n" "$2" "$OUTPUT" >> $OUTPUT_FILE
	fi
}

show_host_info(){
	printf "%s - Respuesta desde %s\n" "$(date "+%Y/%m/%dT%H:%M:%S")" "$1" >> $OUTPUT_FILE
	printf "Respuesta desde %s\n" "$1"
}

# Inicia el escaneo de puertos, iterando por los puertos disponibles y leyendo datos
# desde /dev/tcp/[HOST]/[PUERTO]
scan_ports(){
	local TARGET=$1
	rm -f $OUTPUT_FILE
	printf "${YELLOW}*${GREEN} Buscando puertos abiertos en ${YELLOW}%s\n${RESET}" "$TARGET"
	arping -c 1 -w 1 $TARGET > /dev/null 2>&1
	if [ $? -ne 0 ]; then
		error "Destino no encontrado"
		exit 1
	fi
	printf "%s - Resultados:
PUERTO > SALIDA DEL PUERTO >> RESPUESTA A PETICION HTTP ;\n" "$(date '+%Y/%m/%dT%H:%M:%S')" > $OUTPUT_FILE
	for I in $(seq 1 65535); do
		if [ $(( $I % 5000 )) -eq 0 ]; then
			[ $VERBOSE -eq 1 ] && printf "${YELLOW}>>${RESET} escaneados %5i puertos\n" "$I" || echo -n "."
		fi
		timeout 1 bash -c "< /dev/tcp/$1/$I" 2>/dev/null && show_port_info "$TARGET" "$I"  &
	done; wait
	printf "\n\n${YELLOW}* ${GREEN}Resultados:${RESET}
${YELLOW}PUERTO > SALIDA DEL PUERTO >> RESPUESTA A PETICION HTTP ;\n"${RESET}
	tail -n +3 $OUTPUT_FILE  | sort -n
	printf "${YELLOW}* ${GREEN}Los resultados encontrados se guardaron en ${YELLOW}%s\n${RESET}" "$OUTPUT_FILE"
}

get_int_from_ip(){
	local o1 o2 o3 o4
	{ IFS=. read o1 o2 o3 o4; } <<< $1
	echo $(((((((o1 << 8) | o2) << 8) | o3) << 8) | o4))
}

get_ip_from_int(){
	local IP N INT=$1
	for N in 1 2 3 4; do
		IP=$((INT & 0xff))${IP:+.}$IP
		INT=$((INT >> 8))
	done
	echo $IP
}

get_class_from_mask(){
	echo 1
}

get_ip_from_netmask(){
	local VALUE=$((0xffffffff << (32 - $1)))
	printf "%i.%i.%i.%i" "$((($VALUE & 0xFF000000) >> 24))" "$((($VALUE & 0xFF0000) >> 16))" \
		"$((($VALUE & 0xFF00) >> 8))" "$(($VALUE & 0xFF))"
}

get_wildcard_from_netmask(){
	local VALUE=$((0xffffffff << (32 - $1)))
	VALUE=$(( ~$VALUE ))
	printf "%i.%i.%i.%i" "$((($VALUE & 0xFF000000) >> 24))" "$((($VALUE & 0xFF0000) >> 16))" \
		"$((($VALUE & 0xFF00) >> 8))" "$(($VALUE & 0xFF))"
}

echo_byte() {
	local N BITS
	for (( N=$1; N>0; N>>=1)); do
		BITS=$((N&1))$BITS;
	done
	printf "%08i" "${BITS-0}"
}

get_bit_from_ip(){
	local S
	for S in $(echo "$1" | tr . " " ); do
		echo -n "$(echo_byte $S) "
	done
}

get_network_from_address_mask(){
	local NETWORK
	IFS='.' read -r -a ADDRESS <<< "$1"
	IFS='.' read -r -a MASK <<< "$2"
	for I in $(seq 0 3); do
		NETWORK="$NETWORK.$(( ${ADDRESS[$I]} & ${MASK[$I]} ))"
	done
	printf "%s" "${NETWORK#.*}"
}

get_broadcast_from_network_and_wildcard(){
	local BROADCAST
	IFS='.' read -r -a NETWORK <<< "$1"
	IFS='.' read -r -a WILDCARD <<< "$2"
	for I in $(seq 0 3); do
		BROADCAST="$BROADCAST.$(( ${NETWORK[$I]} | ${WILDCARD[$I]} ))"
	done
	printf "%s" "${BROADCAST#.*}"
}

format_net_info(){
	printf "  %-9s:\t%-15s\t\t%s\n" "$1" "$2" "$(get_bit_from_ip $2)"
}

# Realiza el calculo de los parametros de la red, para despues iterar por
# todos los hosts disponibles enviando un ping arp
scan_hosts(){
	printf ${YELLOW}"* ${GREEN}Calculando informacion de la red:\n"${RESET}
	local TARGET=$1
	echo "$TARGET" | grep -E '^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/[0-9]{1,2}$' > /dev/null 2>&1
	if [ $? -ne 0 ]; then
		error "IP/Mascara no validas, el formato es, por ejemplo '192.168.1.0/24'"
		exit 1
	fi
	local ADDRESS=${TARGET%/*}
	local MASK=${TARGET#*/}
	if [ $MASK -gt 32 ]; then
		error "Mascara no valida, debe tener un valor entre 0 y 32 incluidos"
		exit 1
	fi

	local NETMASK=$(get_ip_from_netmask $MASK)
	local WILDCARD=$(get_wildcard_from_netmask $MASK)
	local NETWORK=$(get_network_from_address_mask "$ADDRESS" "$NETMASK")
	local BROADCAST=$( get_broadcast_from_network_and_wildcard "$NETWORK" "$WILDCARD" )
	local HOSTMIN HOSTMAX HOSTMIN_INT HOSTMAX_INT IP HOST_INT
	HOSTMIN_INT=$(get_int_from_ip $NETWORK)
	HOSTMIN_INT=$(( ++HOSTMIN_INT ))
	HOSTMIN=$( get_ip_from_int $HOSTMIN_INT )
	HOSTMAX_INT=$(get_int_from_ip $BROADCAST)
	HOSTMAX_INT=$(( --HOSTMAX_INT ))
	HOSTMAX=$( get_ip_from_int $HOSTMAX_INT )

	format_net_info "Address" "$ADDRESS"
	format_net_info "Netmask" "$NETMASK"
	format_net_info "Wildcard" "$WILDCARD"
	echo
	format_net_info "Network" "$NETWORK"
	format_net_info "Broadcast" "$BROADCAST"
	format_net_info "HostMin" "$HOSTMIN"
	format_net_info "HostMax" "$HOSTMAX"
	echo
	echo >> $OUTPUT_FILE

	HOST_INT=$HOSTMIN_INT
	printf "${YELLOW}* ${GREEN}Buscando hosts desde ${YELLOW}$HOSTMIN${GREEN} a ${YELLOW}$HOSTMAX${RESET}:\n"${RESET}
	printf "%s - Buscando hosts desde %s a %s:\n" "$(date "+%Y/%m/%dT%H:%M:%S")" "$HOSTMIN" "$HOSTMAX" > $OUTPUT_FILE
	while [ $HOST_INT -lt $HOSTMAX_INT ]; do
		IP=$(get_ip_from_int $HOST_INT)
		HOST_INT=$(( HOST_INT + 1 ))
		[ "${IP#*.*.*.*}" == "0" -o "${IP#*.*.*.*}" == "255" ] && continue
		[ $VERBOSE -eq 1 ] && printf "Escaneando %s\n" "$IP"
		printf "%s - Escaneando %s\n" "$(date "+%Y/%m/%dT%H:%M:%S")" "$IP" >> $OUTPUT_FILE
		arping -c 1 -w 20 "$IP" > /dev/null 2>&1 && show_host_info "$IP" &
	done; wait
	printf "${YELLOW}* ${GREEN}Los resultados encontrados se guardaron en ${YELLOW}%s\n${RESET}" "$OUTPUT_FILE"
}

show_menu(){
	printf "
*** MENU ***
1 - Busca hosts
2 - Busca puertos
3 - Sniff

Ingrese una opción:
_ "
	read COMMAND
	case "$COMMAND" in
		1)
			read -p "Ingresa una red con máscara (192.168.1.1/24 por ejemplo): _ " PARAM
			bash $0 -v -H $PARAM
			;;
		2)
			read -p "Ingresa la dirección del objetivo (192.168.1.1 por ejemplo): _ " PARAM
			bash $0 -v -P $PARAM
			;;
		3)
			read -p "Ingresa una interfaz de red por la cual comenzar la escucha (eth0, por ejemplo): _ " PARAM
			bash $0 -v -S $PARAM
			;;
		*)
			printf "! ERROR: Opcion invalida\n"
			;;
	esac
	exit 0
}

# # #

if [ -z "$1" ]
then
	usage
fi

ARGS=("${@}")
I=0
while [ $I -lt ${#ARGS[@]} ]
do
	OUTPUT_FILE=
	TIMESTAMP=$(date "+%Y%m%d.%H%M%S")
	COMMAND=${ARGS[$I]}
	case "$COMMAND" in
		help)
			usages
			;;
		hosts|-H)
			OUTPUT_FILE=$TIMESTAMP-hosts.log
			scan_hosts "${ARGS[@]:$(($I+1))}"
			I=$(( I+1 ))
			;;
		ports|-P)
			OUTPUT_FILE=$TIMESTAMP-ports.log
			scan_ports "${ARGS[@]:$(($I+1))}"
			I=$(( I+2 ))
			;;
		sniff|-S)
			OUTPUT_FILE=$TIMESTAMP-sniff.pcap
			start_sniff "${ARGS[@]:$(($I+1))}"
			I=$(( I+2 ))
			;;
		verbose|-V|-v)
			VERBOSE=$([ $VERBOSE -eq 1 ] && echo 0 || echo 1)
			if [ $VERBOSE -eq 1 ]; then
				printf "${YELLOW}* ${GREEN}Activado modo verboso\n${RESET}"
			else
				printf "${YELLOW}* ${GREEN}Desactivado modo verboso\n${RESET}"
			fi
			;;
		menu|-m)
			show_menu
			;;
		*)
			printf "!${RED}ERROR:${RESET} Comando ${BLUE}$COMMAND${RESET} no encontrado\n"
			usage
			exit 1
	esac
	I=$(( I+1 ))
	echo
done

#################################################################
# *** Grupo N°1 *** 						#
# - Integrante 1: Camilo Hernan Rojas Vera			#
# - Integrante 2: Cristian Francisco Rocco Salgado		#
# - Integrante 3: Pablo Andrés Mansilla Ojeda			#
# - Integrante 4: Diego Nicolas Espindola Olav			#
# - Integrante 5: Misael Hemdan Israel López Flores		#
#################################################################
